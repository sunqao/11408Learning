# 数据结构（2）- 链表，日期

## 链表

**结构体与构造函数：**

```cpp
struct Node{
    int val;
    Node *next;
    
    //默认构造函数，创建时不传递任何参数初始化成员变量
    Node() : val(0), next(NULL){
        
    }
    //重载构造函数，传递一个参数时调用
    Node(int num) : val(num), next(NULL){
    }
    //重载构造函数，传递两个参数时使用
    Node(int num, Node* p): val(num), next(p){
        
    }
   	//析构函数，当对象被销毁的时候调用
    ~Node(){
        
    }
}

int main(){
    Node n1;//调用默认构造函数
    Node n2(1);//调用第二个构造函数
    Node n3(2, NULL);//调用第三个构造函数
    return 0;//主函数结束，内存释放，调用析构函数
}
```

**结构体与指针：**

```cpp
struct Node{
    int val;
    Node *next;
    //默认构造函数和析构函数都可以不写，C++会自动生成
    Node() : val(0), next(NULL){
    }
    
    Node(int num) : val(0), next(NULL){
    }
}

int main(){
    Node* n1 = new Node();//new关键字创建一个结构体对象并返回这个结构体的指针
    Node* n2 = new Node(1);
    Node n3(3);
    //指针只有这两种使用成员变量的方式
    cout << n1->val << (*n1).val << endl;
    //非指针只有这一种使用成员变量的方式
    cout << n3.val << endl;
    
    //delete关键字用来释放内存，这里释放的是n1指向的内存，n1这个变量在后面还是可以再次赋值使用的
    delete n1;
    delete n2;
    
    return 0;
}
```

单链表太简单的就不再赘述，这里只介绍双向链表

在使用双向链表的时候我们需要先定义前后两个哨兵，这样后面再进行操作的时候将不用特判是不是头结点和尾结点，另外单链表的操作需要注意顺序问题，双链表也需要顺序问题，双链表的定义和添加结点如下所示：

```cpp
struct Node{
    int val;
    Node* prev;
    Node* next;
    Node() : val(0), prev(NULL), next(NULL){
        
    }
}

int main(){
    //先定义前后两个哨兵
    Node* head = new Node();
    Node* tail = new Node();
    head->next = tail;
    tail->prev = head;
    
    //插入一个结点到head后面
    Node* a = new Node();
    a->next = head->next;
    a->prev = head;
    head->next = a;
    a->next->prev = a;
    
    //插入一个结点到a的后面
    Node* b = new Node();
    b->next = a->next;
    b->prev = a;
    a->next = b;
    b->next->prev = b;
    
    //删除结点b
    b->prev->next = b-next;
    b->next->prev = b->prev;
    delete b;
    
    
    delete head;
    delete tail;
    delete a;
    return 0;
}
```

如果是循环双向链表，此时前后两个哨兵设置为一个就可以了，其他的操作完全相同，如果想要判断正确的话可以看作两个不同方向的循环单链表，不过这里记住即可，反正双向链表设置哨兵将会非常方便很容易记忆，只是需要在遍历的时候注意一下：

```cpp
struct Node{
    int val;
    Node* prev;
    Node* next;
    Node() : val(0), prev(NULL), next(NULL){
        
    }
}

int main(){
    //先定义前后两个哨兵
    Node* head = new Node();
    Node* tail = head;//两个哨兵都是自己
    head->next = tail;//前驱指向自己
    tail->prev = head;//后继指向自己
    
    //插入一个结点到head后面
    Node* a = new Node();
    a->next = head->next;
    a->prev = head;
    head->next = a;
    a->next->prev = a;
    
    //插入一个结点到a的后面
    Node* b = new Node();
    b->next = a->next;
    b->prev = a;
    a->next = b;
    b->next->prev = b;
    
    //删除结点b
    b->prev->next = b-next;
    b->next->prev = b->prev;
    delete b;
    
    
    delete head;
    delete tail;
    delete a;
    return 0;
}
```



