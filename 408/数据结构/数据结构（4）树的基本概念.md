# 数据结构（4）树的基本概念

## 树的基本概念：

**结点的度数：**一个结点的子结点的个数称为这个结点的度数，所有叶子结点的度数为`0`

**树的度数：**一个树中度数最大的结点的度数成为这个树的度数

**兄弟结点：**具有相同父结点的结点互为兄弟结点

另外在408的考题中所有的树都是无向的树

**结点的层次：**在树中根结点为第一层，根结点的子结点是第二层

**树的高度或者深度：**树中结点的最大层次

**森林：**若干棵互不相交的树构成的集合成为森林，一棵树也可以认为是森林

## 二叉树

每一个点的度数最多是2的树成为二叉树，另外空结点，单结点都是二叉树，然后二叉树的左子树和右子树是有区分的，二叉树有左右之分哪怕左右子树完全一样

### **性质：**

1. 在非空的二叉树中第`i`层上最多有`2^(i - 1)`个结点
2. 一个深度为`k`的二叉树的结点最多是有`2^k - 1`个结点（根据性质1将每一层的所有最多结点加起来）

> **满二叉树：**
>
> 一个深度为`k`且，结点个数为`2^k - 1`个结点的二叉树

3. 一个包含`n`个结点的二叉树的边数是`n - 1`，因为只有根节点没有对应一个边连接父节点，其他点都对应一个边链接到自己的父节点

4. 对于任何一个二叉树，若其叶子结点数为`n0`，度为`2`的结点数为`n1`，则`n0 = n1 + 1`

> 假设`n0`是度数为`0`的点的数量，`n1`是度数为`1`的点的数量，`n2`为度数为`2`的点的数量，总结点数`n = n0  + n1 + n2`
>
> 度数为`0`的点没有儿子，也就没有一个边链接子节点，度数为`1`的点有一个边链接子节点，度数为`2`的点有一个边链接父节点，因此有`n - 1 = n1 + 2 * n2`即`n = n1 + 2n2 + 1`
>
> 带入`n0 + n1 + n2 = n1 + 2n2 + 1`，得到：`n0 = n1 + 1`

**完全二叉树：**

如果深度为`k`，有`n`个结点的二叉树，当且仅当这个二叉树的每个结点都与深度为`k`的满二叉树的结点编号从`1 ~ n`一一对应，那么这个树就称为完全二叉树

也就是说完全二叉树除了最下面一层从右到左比满二叉树少了一些结点之外，其他的结点全都一一对应，完全二叉树的最后一层结点全都集中在左半边如下图所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-01-22-21-46-23-603_com.jideos.jno.png" alt="Screenshot_2024-01-22-21-46-23-603_com.jideos.jno" style="zoom: 50%;" />

**完全二叉树的高度：**$ \lfloor log_2n \rfloor + 1$，`n`是完全二叉树结点的个数，下取整加一，向下取整的意思是向下舍入到最接近的整数

> 完全二叉树每一层最左侧的结点的编号就是2的幂次方，它取对数加一就是它的深度，由于每一层最左侧的结点的编号分别以2的次幂递增，因此对于第`k`层的结点，最左侧的结点的编号为`2^(k - 1)`，对于第`k + 1`层的结点最左侧的编号是`2^(k)`，所以对于第`k`层的任意一个结点，他的编号都在`2^(k - 1) ~ 2^k`之间，结点的编号也就是结点的到根节点的结点的个数，所以第`k`层结点的编号取对数在`k - 1 ~ k`之间，向下取整就是`k - 1`，再加一就恰好是这一层的高度
>
> 因此如果一个完全二叉树的高度为`h`，那么最后一层的所有结点的编号取对数的范围都是[k - 1, k)，最后一个结点的编号为`n`，同时也是二叉树的结点的个数，因此`n`取对数再加一就一定是高度`h`了

**完全二叉树的结点编号规律：**如果一个完全二叉树的结点的编号为`x`，那么它的左儿子的结点的编号是`2x`，它的右儿子的节点的编号是`2x + 1`

### 存储：

**顺序存储结构：**

通过上述的二叉树的结点的编号规律，给二叉树的每个结点编号，然后存放到对应的数组的下标的空间中；需要注意的是如果不是一个完全二叉树仍然按照结点的编号存储的话会造成空间的浪费

**链式存储结构：**

用一个结构体来存放一个结点，如下所示：

```cpp
struct TreeNode{
    int val;
    TreeNode *left;
    TreeNode *right;
    
    TreeNode(int x): val(x), left(NULL), right(NULL){}
}
```

### 二叉树的遍历（递归）

代码如下，不再赘述：

**前序遍历：**先遍历根结点，再遍历左子树，再遍历右子树

```cpp
void f(TreeNode* root){
    if(root) cout << root->val;
    if(root->left) f(root->left);
    if(root->right) f(root->right);
}
```



**中序遍历：**先遍历左子树，再遍历根结点，再遍历右子树

```cpp
void f(TreeNode* root){
    if(root->left) f(root->left);
    if(root) cout << root->val;
    if(root->right) f(root->right);
}
```



**后续遍历：**先遍历左子树，再遍历右子树，再遍历根节点

```cpp
void f(TreeNode* root){
    if(root->left) f(root->left);
    if(root->right) f(root->right);
    if(root) cout << root->val;
}
```

**由前序遍历和中序遍历构造二叉树：**

![image-20240125201658643](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240125201658643.png)

**解题思路：**

对于任意一个二叉树的前序遍历的结果，第一个元素`a`一定是根节点；因此找到中序遍历中的`a`元素，此时中序遍历中`a`左边的元素一定是左子树的元素，`a`右边的元素一定是右子树的元素，由中序遍历可以找到左子树和右子树的元素的个数，从而在前序遍历的结果中挑出这些元素；并且这些元素顺序都是各自的子树前序遍历和中序遍历的结果，因此我们递归构造即可；二叉树的前序和中序遍历的结果结构如下图所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-01-25-20-26-00-249_com.jideos.jno.png" alt="Screenshot_2024-01-25-20-26-00-249_com.jideos.jno" style="zoom:50%;" />

前序遍历找到根节点，中序遍历用来确定左子树和右子树的大小

**代码实现：**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(preorder.size() == 0) return NULL;
        TreeNode *root = new TreeNode(preorder[0]);
        int numL = 0;
        int numR = 0;
        //找到根节点以及计算出左子树的结点的个数
        for(int i = 0; i < inorder.size(); i ++){
            if(inorder[i] == preorder[0]) break;
            numL ++;
        }
        numR = inorder.size() - numL - 1;
        int lPreStart = 1;//左子树的先序遍历的起点下标
        int lPreEnd = lPreStart + numL - 1;//左子树先序遍历的结尾下标
        int rPreStart = numL + 1;//右子树的先序遍历的起点下标
        int rPreEnd = rPreStart + numR - 1;//右子树的先序遍历的结尾下标
        
        int lInStart = 0;//左子树中序遍历的起点下标
        int lInEnd = lInStart + numL - 1;//左子树中序遍历的结尾下标
        int rInStart = numL + 1;//右子树中序遍历的起点下标
        int rInEnd = rInStart + numR - 1;//右子树中序遍历的结尾下标
        
        root->left = build(preorder, inorder, lPreStart, lPreEnd, lInStart, lInEnd);
        root->right = build(preorder, inorder, rPreStart, rPreEnd, rInStart, rInEnd);
        
        return root;
        
    }
    
    //找到子树的根节点并返回
    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int preStart, int preEnd, int inStart, int inEnd){
        if(preEnd < preStart) return NULL;
        
        TreeNode * root = new TreeNode(preorder[preStart]);
        int numL = 0;
        int numR = 0;
        for(int i = inStart; i < inorder.size(); i ++){
            if(inorder[i] == preorder[preStart]) break;
            numL ++;
        }
        numR = preEnd - preStart + 1 - numL - 1;
        int lPreStart = preStart + 1;//左子树的先序遍历的起点下标
        int lPreEnd = lPreStart + numL - 1;//左子树先序遍历的结尾下标
        int rPreStart = lPreEnd + 1;//右子树的先序遍历的起点下标
        int rPreEnd = rPreStart + numR - 1;//右子树的先序遍历的结尾下标
        
        int lInStart = inStart;//左子树中序遍历的起点下标
        int lInEnd = lInStart + numL - 1;//左子树中序遍历的结尾下标
        int rInStart = lInEnd + 2;//右子树中序遍历的起点下标
        int rInEnd = rInStart + numR - 1;//右子树中序遍历的结尾下标
        
        root->left = build(preorder, inorder, lPreStart, lPreEnd, lInStart, lInEnd);
        root->right = build(preorder, inorder, rPreStart, rPreEnd, rInStart, rInEnd);
        
        return root;
        
    }
};
```

如果用哈希表在中序遍历中找根节点的话时间复杂度就是线性的，这里不再赘述

### 线索二叉树

**结点的前驱：**对一个二叉树进行中序遍历，最后结果的这个结点的前一个结点就是这个节点的前驱

**结点的后继：**对一个二叉树进行中序遍历，最后结果的这个结点的后一个结点就是这个节点的后继

对二叉树的指针域做如下规定：

1. 若结点没有左儿子，则左指针指向这个结点的前驱，若结点没有右儿子，则右指针指向这个结点的后继
2. 增加两个标志域，`Ltag`和`Rtag`用来表示指向的是子节点还是前驱和后继

指向前驱和后继的指针叫做线索，按照某种次序遍历（先序，中序，后序），加上线索的二叉树叫做线索二叉树

## 树和森林

