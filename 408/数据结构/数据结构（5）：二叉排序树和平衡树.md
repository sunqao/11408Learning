# 数据结构（5）：二叉排序树和平衡树

## 二叉排序树

中序遍历有序的二叉树称为二叉排序树，也叫做二叉搜索树（BST），**递归定义：**每个结点的左子树所有结点都小于这个结点，每个结点的右子树所有结点都大于这个结点

这里只讨论左右结点都严格小于和大于父节点的情况，相等情况类似，可以归到左节点也可以归到右节点

### 二叉排序树的操作：

二叉搜索树有三个操作：插入，删除，查找，这三个操作的时间复杂度都是`O(h)`的，`h`是二叉排序树的高度

**插入操作：**

从根节点开始，假如插入的这个值`x`小于当前结点，则插入到左子树，否则插入到右子树

这样的操作保证插入的这个结点一定在叶节点上，且每次比较都可以保证当前结点满足递归定义，因此插入完成之后整个树仍然是二叉排序树

**删除操作：**

如果删除的这个结点是叶结点，则直接删除

如果删除的这个结点只有左子树或者只有右子树，则用这个结点的左子树的根节点或者右子树的根节点替代这个结点即可，删除的这个结点的子树的结构没有改变，且剩下的结点也满足二叉排序树的定义，因此整个树仍是二叉排序树

如果删除的这个结点既有左子树也有右子树，假设这个结点是`A`，那么将整个树的中序遍历的结果中`A`的前驱的值复制到`A`的位置，并删掉`A`的前驱，这样操作后二叉树的中序遍历的结果仍然是有序的，结果仍是二叉树排序树；`A`的前驱从树的结果上来看就是`A`的左子树中的最大的结点；左子树最大的那个结点一定是遍历左子树一直向右直到某个结点没有右子树，此时这个结点就是左子树的最大结点，此时我们递归删除这个结点即可（这个结点也分两种情况，有左子树或者没有左子树）

**查找操作：**

假如查找的值是`x`，如果`x`小于当前结点，查找左子树，如果`x`大于当前结点，查找右子树，查找的话一般都是用的这种方式

**代码实现：**

![image-20240129214040257](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240129214040257.png)

```cpp
```



```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<climits>

using namespace std;

struct TreeNode{
    int val;
    TreeNode *left, *right;
    TreeNode(int _val): val(_val), left(NULL), right(NULL){}
}*root;

//插入操作
//引用，因为root可以发生改变
void insert(TreeNode *&root, int x){
    if(!root) root = new TreeNode(x);
    else if(x < root->val) insert(root->left, x);
    else insert(root->right, x);
}

//删除操作
void remove(TreeNode* &root, int x){
    //如果删除的数不存在
    if(!root) return;
    if(root->val > x) remove(root->left, x);//如果小于根节点，去左子树删除
    else if(root->val < x) remove(root->right, x);//如果大于根节点，去右子树删除
    else{
        //x等于当前根节点的值，分三种情况
        if(!root->right && !root->left) root = NULL;//如果要删除的结点时叶节点
        else if(!root->right) root = root->left;//如果右子树为空，将左子树提上去
        else if(!root->left) root = root->right;//如果左子树为空，将右子树提上去
        else{//如果左右子树都存在
            //找到左子树最大值的那个结点，即中序遍历后当前结点的前驱
            auto p = root->left;
            while(p->right) p = p->right;
            root->val = p->val;
            //去左子树中删除前驱
            remove(root->left, p->val);
        }
        
    }
}

//getPre表示返回x在以root为根节点的树中的前驱
int getPre(TreeNode *root, int x){
    //如果root为空表示x没有前驱，这里定义为负无穷
    if(!root) return -INT_MAX;
    //如果当前结点的值小于x，那么x在当前树中的前驱是当前结点以及x在当前结点右子树的前驱取大的结果
    if(root->val < x) return max(root->val, getPre(root->right, x));
    //如果当前结点小于等于x，那么x在当前树中的前驱也就是x在当前结点左子树中的前驱
    else if(root->val >= x) return getPre(root->left, x);
}

int getBack(TreeNode *root, int x){
    if(!root) return INT_MAX;
    
    if(root->val <= x) return getBack(root->right, x);
    else if(root->val > x) return min(root->val, getBack(root->left, x));
}

int main(){
    int n;
    cin >> n;
    while(n --){
        int t, x;
        cin >> t >> x;
        
        //插入操作
        if(t == 1) insert(root, x);
        else if(t == 2) remove(root, x);//删除操作
        else if(t == 3) cout << getPre(root, x) << endl;
        else if(t == 4) cout << getBack(root, x) << endl;
         
    }
    
    return 0;
}
```

这个例子是寻找前驱，这里的思路与寻找点是完全一样的，这里用正无穷和负无穷当作边界特殊值，便于结果处理

## 平衡树

**定义：**

是一颗二叉排序树且每个结点的左子树和右子树的高度差最多为1，另外平衡树的高度是`log(n)`级别，`n`是节点的个数，因此平衡二叉树的插入，删除，查找的操作的时间复杂度都是`O(log(n))`的

**平衡因子：**

一个结点的左子树的高度减去右子树的高度，取值为`-1, 0, 1`

### 平衡操作

**树的旋转：**

不管是左旋还是右旋，都不改变树的中序遍历的结果，旋转操作如下图所示，简单来说就是`A，C`两个结点交换一下位置然后`d`这个子树改变下挂载的结点，旋转之后中序遍历不变，可以以此来验证旋转的正确性：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-01-30-20-56-22-280_com.jideos.jno.png" alt="Screenshot_2024-01-30-20-56-22-280_com.jideos.jno" style="zoom:50%;" />

**平衡操作：**

 我们从下到上找到最小不平衡的子树，假设这个子树的根节点为`A`，如下图所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-01-30-21-38-42-957_com.jideos.jno.png" alt="Screenshot_2024-01-30-21-38-42-957_com.jideos.jno" style="zoom:50%;" />

这里的不平衡分为四种情况

**LL型：**

这个子树的根节点`A`的左儿子的左子树的高度过高导致不平衡，这时直接右旋根结点`A`：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-01-30-21-41-54-935_com.jideos.jno.png" alt="Screenshot_2024-01-30-21-41-54-935_com.jideos.jno" style="zoom:50%;" />

**RR型：**

这个子树的根结点`A`的右儿子的右子树的高度过高导致不平衡，这时直接左旋根结点`A`：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-01-30-21-44-02-834_com.jideos.jno.png" alt="Screenshot_2024-01-30-21-44-02-834_com.jideos.jno" style="zoom: 50%;" />

**LR型：**

这个子树的根结点`A`的左儿子的右子树的高度过高导致不平衡，这时先左旋`B`，再右旋`A`，可以看到，一开始是`LR`型的，但是左旋`B`之后变成了`LL`型，所以需要再右旋一次`A`

至于为什么左旋一次`B`之后变成`LL`型的，是因为子树`d`和`H`的高度最多差`1`，假设`d`比`H`的高度少一，那么`B`左旋之后`d`下降，`H`的左子树又多了一层`B`，此时子树`B`的高度就和之前的`H`的高度一样了，显然变成了`LL`型；假设`d`比`H`的高度相等或多一，那左旋之后子树`B`的高度更高，显然是`LL`型

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-01-30-21-54-07-775_com.jideos.jno.png" alt="Screenshot_2024-01-30-21-54-07-775_com.jideos.jno" style="zoom: 50%;" />

**RL型：**

