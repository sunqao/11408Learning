# 数据结构（6）：Huffman树和Huffman编码

## 前缀编码

**定义：**

对某个字符集进行编码，要求字符集中任意字符的编码都不是其他字符的编码的前缀

比如字符串`aabccccdd`，可以用`a->01, b->10, c->110, d->0000`，因此这个字符串的编码就是：`01011011011011011000000000`，因为编码的方式是前缀编码，所以讲这个`01`串的解码过程就是唯一的

**编码长度：**

`a`出现的次数是`W1 = 2`，`a`的编码长度`L1 = 2`，所以`a`对应的字符串编码长度就是`W1 * L1 = 4`

`b`出现的次数是`W2 = 1`，`b`的编码长度`L2 = 2`，所以`b`对应的字符串编码长度就是`W2 * L2 = 2`

`c`出现的次数是`W3 = 4`，`c`的编码长度`L3 = 3`，所以`c`对应的字符串编码长度就是`W3 * L3 = 12`

`d`出现的次数是`W4 = 2`，`d`的编码长度`L4 = 4`，所以`d`对应的字符串编码长度就是`W4 * L4 = 8`

我们将`a, b, c, d`的编码构造一颗树（`0`往左，`1`往右），如下图所示，每一个字符的编码都是从根节点走到这个字符的路径：

![Screenshot_2024-02-04-19-35-12-852_com.jideos.jno](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-02-04-19-35-12-852_com.jideos.jno.png)

可以发现，如果一组字符集的编码是前缀编码`<=>`根据上述方法构造树的话每个字符都只会是叶结点，任意一套前缀编码都可以对应一颗二叉树

## **带权路径长度（WPL）**

一个叶结点的带权路径长度是这个节点的权值乘以根节点到这个叶结点的路径长度，一颗树的带权路径长度是所有叶结点的带权路径长度之和，我们把上述二叉树的叶结点的权定义为字符在原字符串中出现的次数，那么这棵树的带权路径长度就是原字符串编码后的编码长度

因此根据上述定义，这个二叉树就是与前缀编码完全等价的

我们需要找到一个前缀编码使得原字符串编码后的编码长度最小，也就是构造一颗带权路径长度最小的二叉树，我们随机给这棵树的边赋值`01`，每个叶结点的路径就是这个字符的编码，这个编码就是`Huffman`编码，这棵二叉树就是`Huffman`树，构造过程就是`Huffman`编码的过程

## Huffman树的证明与构造

假设我们找到了上述这棵树（作为一个解），那么这颗树有如下性质：

1. **这颗树的内部节点的度数一定是`2`**

假如有个节点的度数是`1`，那么这个内部节点一定可以被他的子节点代替，因此这个分支上的叶结点的带权路径长度会减小，整个树的带权路径长度变小，那么当前有度数为`1`的内部节点的这棵树就不是最小的带权路径长度的树，出现矛盾

2.  **一定存在一颗这样的树（一个解），使得权值最小的两个点互为兄弟节点**

先证明**权值最小的点B一定在最底层**：

假设它不再最底层，那么一定存在一个在最底层的节点`A`，其深度大于这个节点`B`，且权值大于这个节点`B`，此时的树是`T1`，那么此时我们交换节点`A,B`，形成新的树`T2`，那么`T2`的带权路径长度一定小于`T1`的带权路径长度，与`T1`是一个解矛盾，所以权值最小的节点一定在这棵树的最底层

假设一个可行解的权值最小的两个点`a, c`的结构如下图所示，权值最小的两个点没有互为兄弟节点：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-02-04-19-40-53-892_com.jideos.jno.png" alt="Screenshot_2024-02-04-19-40-53-892_com.jideos.jno" style="zoom:50%;" />

调整节点`c`和`b`，因为`c, b`两个节点的深度都是一样的，所以调整后的树的带权路径长度和原来的一样，因此调整后的树也是一个可行解，所以一定存在一个可行解使得权值最小的两个点互为兄弟节点，因此对于任意一个可行解（一颗这样的树），都可以转化为权值最小的两个点互为兄弟节点的解，权值最小的两个点互为兄弟节点的可行解构成的集合`[C]`就可以当做可行解集

3. **`n`个字符节点的可行解集`[C]`，对于其中的任意一个可行解`treeA`，合并权值最小的两个节点变成`z`，此时变成了`n-1`个节点，这`n－1`个节点对应的可行解集为`[C2]`；此时去掉`treeA`中的权值最小的两个节点，添加节点`z`保持结构不变形成`treeB`，`treeB`一定是`[C2]`中的元素**

如下图所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-02-04-19-46-40-926_com.jideos.jno.png" alt="Screenshot_2024-02-04-19-46-40-926_com.jideos.jno" style="zoom:50%;" />

这里用反证法证明为什么`treeB`一定是`[C2]`中的元素：

假设`treeB`此时的带权路径长度不是最小的，也就是`z*(hz) + other`（`other`是其他叶结点的带权路径长度，`hz`是此时`z`的路径长度）不是最小的，而`treeA`的路径长度是`a*(hz + 1) + b*(hz +1）+ other = (hz)*z + z + other`，`z`是定值，`z*(hz) + other`不是最小的，也就说明`(hz) * z + z + other`不是最小的，这与`treeA`是一个可行解矛盾，因此此时`treeB`的带权路径长度就应该是最小的，也应该是`[C2]`集合中的一个可行解

而对集合`[C2]`中的任意一个元素，同上面的证明方式，我们将`z`拆开，就对应了集合`[C]`中的一个元素，因此集合`[C2]`与`[C]`中的树的结构是一一对应，只是集合`[C]`中的树的带权路径长度比`[C2]`中多`z`，且多了两个儿子节点`a, c`

根据上面的性质，我们得到了求一个`n`个节点的可行解（也就是构造一个可行的二叉树）的算法，伪代码如下：

```cpp
Create(n):表示构造n个节点的可行解
1. 取出n个节点中的权值最小的两个节点a, b
2. 合并成一个节点z且a,b作为z的左右儿子节点
3. 去除a, b节点，加入节点z，变成n - 1个节点
4. 递归构造这n - 1个节点的可行解Create(n - 1)
```

通过以上算法得到的二叉树称为`Huffman`树，这个二叉树的编码称为`Huffman`编码

当然也可以从合并代价的角度来考虑证明，两种理解方式完全等价：

[算法基础（四十一）：贪心 - Huffman树 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/672520196?)

不过这里直接记住算法即可，不求掌握证明

## 例子

![image-20240204202248784](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240204202248784.png)

![image-20240204202257947](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240204202257947.png)

合并两个子树的代价是两个子树的根节点的权值和，合并所有子树的代价之和就是合并这颗树的代价，同时也是这个树的所有非叶子结点的结点权值之和，一颗树的带权路径长度就是这颗树的所有叶子结点的带权路径长度之和，同时也是从所有零散的结点合并成这颗树的代价

**代码实现：**

```cpp
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;


int main(){
    int n;
    cin >> n;
    priority_queue<int, vector<int>, greater<int>> heap;//定义一个优先队列
    
    while(n --){
        int x;
        cin >> x;
        heap.push(x);//读入n个果子插入到堆里
    }
    
    int res = 0;
    
    while(heap.size() > 1){
        //取出最小权值的两个结点
        int x = heap.top();heap.pop();
        int y = heap.top();heap.pop();
        
        res += (x + y);
        heap.push(x + y);//加入到堆中
       // cout << x << "  " << y << endl;
    }
    
    cout << res;
    return 0;
    
}

```

## Huffman树的变形`k`叉树编码





