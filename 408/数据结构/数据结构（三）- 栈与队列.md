# 数据结构（三）- 栈与队列

## 存储结构：

**顺序存储结构：**

用一个静态数组存储即可，如下所示：

```cpp
stk[N], top = -1;//栈顶指向最后一个元素
//插入元素
stk[++top] = 1;


stk[N], top = 0;//栈顶指向最后一个元素的下一个元素 
//插入元素
stk[top++] = 1; 
```

普通队列这里就不赘述了，这里只介绍环形队列，根据队头和队尾指针的指向，队列一般有四种写法，这里用最常见的两种写法，`rear`队列尾元素的下一个元素，并且`front`和`rear`每次都在`mod n`的意义下考虑的时候就实现了环形队列：

```cpp
int main(){
    int q[N], front = 0, rear = 0;
    
    front == rear;//队列为空
    front == (rear + 1) % N;//队列满，虽然此时rear指向的是一个空闲的位置，但此时定义为满了
    //这种定义队列的方式最多只能存放n - 1个元素
    
    //插入，此时队尾指针应该指向的是一个空闲位置
    q[rear] = 1;
    rear = (rear + 1) % N;//指向下一个空闲位置的时候取模
    
    //弹出元素
    front = (front + 1) % N;
    
    //返回队头元素
    q[front];
------------------------------------------------------------------------------------------    
    
    //front指向队列的第一个元素，rear指向队列的最后一个元素
    int q[N], front = 0, rear = -1;
   	//这种定义方式同样只能存放n - 1个元素
    front = (rear + 1) % N;//队列为空
    front = (rear + 2) % N;//队列为满
    
    //插入一个元素
    q[rear] = 1;
    rear = (rear + 1) % N;
    
    //弹出一个元素
    front = (front + 1) % N;
    
}
```

**链式存储方式：**

栈的链式存储方式将一个链表的头结点作为栈顶，最后一个元素作为栈底，这样删除时可以快速找到下一个元素的地址，添加的时候直接头插即可，这里不再赘述

另外队列一般就不用环的形式，因为没有必要

## 应用：

**函数调用：**

计算机中的函数调用是按照栈的形式进行调用的，不过其实函数的调用过程可以画出一颗`dfs`的过程调用树，如下所示：

```cpp
void f3(){
    f4();
}

void f2(){
    
}

void f1(){
    f2();
    f3();
}


int main(){
    f1();
}
```

变成一颗树如下图所示，红色是向下指向，黄色就是返回，其实就是一个`dfs`的过程：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-01-17-20-11-51-763_com.jideos.jno.png" alt="Screenshot_2024-01-17-20-11-51-763_com.jideos.jno" style="zoom: 50%;" />

只调用一个函数的情况下就是一个栈了，如下所示，每调用一个函数就入栈，每返回一个元素就出栈：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-01-17-20-12-41-475_com.jideos.jno.png" alt="Screenshot_2024-01-17-20-12-41-475_com.jideos.jno" style="zoom:50%;" />

因此所有的递归都可以用一个栈来实现，另外需要注意一个尾递归的概念，如果函数在调用结束返回的时候不需要做什么操作，那么就没必要用栈实现，完全可以用循环来代替，如下所示：

```cpp
void f(int n){
    if(n < 0) return;
    cout << n;
   	f(n - 1);
}

int main(){
    f(5);
    return 0;
}
```

这个递归函数的目的是为了倒序输出数字，当输出完`0`了之后整个程序就可以结束了，就不需要再返回做什么操作了，因此它与下面的程序等价：

```cpp
for(int i = 5; i >= 0; i --) cout << i;
```

**中缀表达式求值：**

这里是用一个栈来模拟树的中序遍历过程，更详细的过程可以看这篇文章：

[表达式求值](https://zhuanlan.zhihu.com/p/576526280)

算法过程如下，这里直接背过即可：

首先创建两个栈，一个是符号栈，一个是数字栈

接着扫描表达式：

1. 如果是数字，直接入栈
2. 如果是左括号，直接入栈
3. 如果是右括号，一直操作遇到左括号
4. 如果是`+ - * /`运算符，一直操作到符号栈栈顶的运算符的优先级`<`当前的运算符

这里的操作指的是取数字栈的栈顶两个元素以及一个符号栈进行运算，最后符号栈为空的时候数字栈的栈顶就是结果

**中缀表达式转后缀表达式：**

**括号匹配：**

