# 计算机组成原理（二）：数据的机器级表示

## 数值数据的表示

**数值数据：**在数轴上可以找到确定的点的数据称为数值数据，无符号整数、带符号整数、浮点数（实数）、十进制数

**非数值数据：**逻辑数（包括位串）、西文字符和汉字等

计算机内部所有的信息都用01进行编码

**机器数：**用`0`和`1`编码的计算机内部的`0/1`序列

**真值：**机器数真正的值，即：现实中带正负号的数

**数值数据表示的三要素：**

1. 进位计数制（是几进制）
2. 定、浮点表示（小数点在哪里）
3. 如何用二进制编码（正负号用01编码，编码的方式是什么，反码，补码，原码?）

要确定一个数值数据的值必须先确定这三个要素

**定点数与浮点数：**小数点位置约定在固定位置的数称为定点数，小数点的位置可浮动的数称为浮点数，浮点数可用一个定点小数和一个定点整数来表示

**定点整数：**小数点总是固定在数的最右边

**定点小数：**小数点总是固定在数的最左边

## 定点数的编码

假设机器数`X`的序列为$X_nX_{n - 1}...X_0$一共`n + 1`位，其中第`n`位的`Xn`是符号位`0`表示正，`1`表示负，那么有

定点整数的真值：$X_T = \pm X_{n - 1}...X_0$

定点小数的真值：$X_T = \pm 0.X_{n - 1}...X_0$​

下面介绍的编码都在上述规定中进行

### 原码

原码带有符号位，原码表示法中，正数和负数的编码表示仅仅符号位不同，数值部分完全相同，原码的编码除了符号位外与真值的二进制序列完全一样，零的表示有两种

```
-10 : 10001010B
-0.625 : 11010000B
+0 : 000...0
-0 : 100...0
```

计算机中的整数都用补码表示，浮点数的尾数还用的是原码定点小数表示

### 补码

在模运算系统中，一个数与它除以模后的余数等价，时钟系统是一个非常典型的模12系统

**两个结论：**

1.  一个负数的补码等于模减该负数的绝对值
2. 对于某一确定的模，某数减去小于模的另一数，总可以用该数加上另一数负数的补码来代替

比如钟表的模12系统，假定钟表时针指向10点，要将它拨向６点，则有两种拨法

1. 倒拨4格：`10 - 4 = 6`
2. 顺拨8格：`10 + 8 = 18 ≡ 6（mod12)`

因此有`10 - 4 ≡ 10 + 8 (mod 12)`，即某数减去小于模的另一数，总可以用该数加上另一数负数的补码来代替

同时有`-4 ≡ 8 (mod 12)`一个负数的补码等于模减该负数的绝对值

**那么以上两个结论就实现了计算机中补码运算加和减的统一**，在计算机中如果有`n`位的话，那么就是一个模`2^n`的系统，当运算结果超出了`n`位的范围，这种情况称为溢出

**补码的定义：**

正数的补码是其本身，负数的补码为模与该负数的绝对值之差：

数$X_T$表示真值

当$X_T$为正数的时候有$[X_T]_补 = X_T = M + X_T (mod M)$

当$X_T$为负数的时候有$[X_T]_补 = M - X_T = M + X_T (mod M)$

因此对于任意一个数$X_T$的补码为$X_T = M + X_T (mod M)$

对于有一个符号位和`n - 1`位数值位的`n`位二进制定点整数的补码的定义为：$X_T = 2^n + X_T (mod 2^n)$，其中$-2^{n - 1} \le M_T <2^{n - 1}$

计算机就是一个`n`位的模系统，以`n = 4`为例，如下图所示：

![Screenshot_2024-02-14-21-03-34-518_com.jideos.jno](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-02-14-21-03-34-518_com.jideos.jno.png)

原本应该对应的真值是`0 ~ 15`，换成补码系统后对应的真值是`-8 ~ 7`，这样做的目的是将所有的减法转换成加法，在上述模`16`的系统中，想要计算`6 - 4`，等价于计算`6 + 12 (mod 16)`，也就是`0110 + 1100 (mod 16)`，根据底层的二进制加法器实现，得到的结果就是`6 - 4`的结果`0001`

`6 + 12 (mod 16)`与`6 - 4 (mod 16)`其实完全等价，`12`对应的真值编码是`1100`，也可看作是`-4`的编码，称为`-4`的补码，且带一个符号位，所以计算机中的模系统的所有二进制机器数都可以看作是数的补码，这样做就避免了减法运算

因此计算机底层电路实现减法的时候本质上还是真值运算，只不过在模系统中得到的结果等价于做减法的结果

**特殊数据的补码：**

$-2^{n - 1}$分别在`n`位和`n + 1`位机器中的表示：

`n` ：$2^{n} - 2^{n - 1} = 1000...000(n - 1个0)$

`n + 1`：$2^{n + 1} - 2^{n - 1} = 1100..00(n - 1个0)$

所以同一个真值在不同位数机器中的补码是不同的

`0`在`n`位机器中的表示：

`+-0 = 2^n +- 0 = 10..00(n个0) = 000..00(n 个 0)`

  补码表示中0的表示唯一，因此`100..000(n个0)`可用来表示最小的负数

**真值和补码的转换：**

正数->补码：符号位取0，其余值同真值一样

负数->补码：符号位取1，其余各位由真值各位取反，末尾加一

补码->正数：真值的符号位正，其数值位不变

补码->负数：真值的符号位负，数值部分各位取反，末尾加一

补码->真值相反数补码：各位取反，末尾加一（最小负数取反的补码会溢出）

###  反码

反码用的很少，这里不再说明

### 移码

用浮点数表示一个数值数据时，实际上是用两个定点数来表示的，用定点小数表示尾数，用定点整数表示指数，一般情况下，浮点数的指数都用一种称为＂移码 ”的编码方式表示。

**定义：**若`E`表示指数，其移码表示的位数为`n`，则$[E]_移 = 2^{n - 1} + E$

由定义可以看出，相同位数同一个真值的数`E`他的补码和移码仅仅符号位不同，补码比移码多`2^(n -1)`，另外定义中的`2^(n - 1)`称为偏置常数，主要用来方便移码比大小时使用的

## 整数的表示

整数无需表示小数点，默认在最右边，因此整数也被称为定点数

### 无符号整数

当一个编码的所有二进位都用来表示数值而没有符号位时，该编码表示的就是无符号整数

无符号数省略了符号位（默认为正），因此字长相同的情况下可以表示更大的范围，`n`位无符号整数可以表示的范围就是`0 ~ 2^n - 1`

### 带符号整数

**现代计算机中统一使用补码来表示带符号整数**，因为计算机本身是一个模`2^n`的系统，根据定义在模系统中某数减去小于模的另一数，总可以用该数加上另一数负数的补码来代替，因此在这个模系统中的所有减法都可以用加法代替，并且符号位也可以参与运算

对于`n`位的补码模系统，它对应的数的真值范围是：$2^{n -1} - 1 \sim -2^{n-1}$

### C语言中的整数类型

**C语言的转换特性**

C语言中允许无符号整数和带符号整数之间的转换，转换后数的真值是将原二进制机器数按转换后的数据类型重新解释得到

如果执行 一个运算时同时有无符号数和带符号整数参加，那么C编译器会隐含地将带符号整数强制类型转换为无符号数

**C语言中的比较大小本质**

C语言是按照运算类型来解释存放在机器中的数，然后对解释完之后的数进行大小比较

`2^31 = 2147483648`

## 实数的表示

### 浮点数的表示格式

对于任意一个实数，可以表示为：
$$
X = (-1)^S *M * R^E
$$
其中`S`是数符取值为`0, 1`分别表示正负，`M`是一个定点小数表示尾数，`E`是一个定点整数表示阶数，`R`是基数一般取默认值，因此，浮点数格式只需规定`S、M`和`E`各自所用的位数 、编码方式和所在的位置，而基数`R`与定点数的小数点位置一样是默认的，不需要明显地表示出来。一般尾数用定点原码小数表示，指数用移码表示